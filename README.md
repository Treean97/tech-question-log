# 기록 및 정리
구현 및 설계에 궁금한 부분 정리 및 기록


## Q : 렌더링 파이프라인

일반적인 GPU 렌더링 파이프라인
  - 애플리케이션 단계 : CPU가 카메라, 조명, 메시, 머테리얼 정보를 준비, 드로우콜* 발행
  - 버텍스 처리 : 버텍스 셰이더가 모델 공간 -> 뷰/클립 공간 변환, 스키닝/모핑, 라이트 프로브 적용 등
  - 테셀레이션, 지오메트리 : 폴리곤을 세분 및 증감
  - 래스터라이즈 : 삼각형을 픽셀 후보로 분해
  - 프래그먼트 처리 : 픽셀 셰이더에서 라이팅, 텍스처의 샘플, BRDF* 계산
  - 테스트 & 블랜딩, 깊이(ZTest), 스텐실*, 알파블렌딩으로 최종 컬러 버퍼에 합성
  - 포스트 프로세싱 : 톤매핑, 블룸, 컬러그레이드, 모션블러 등 화면 효과
  - 출력 : 백버퍼를 화면에 스왑

*드로우콜 : GPU에 이 메시, 배치를 이 머테리얼, 셰이더로 그려라 라고 보내는 그림 명령 1회
  - 배칭(Static, Dynamic), GPU Instancing, SRP Batcher 활용 등으로 최적화 가능
*BRDF : 표면이 빛을 반사하는 방식을 수학적으로 정의한 반사 모델
  - Diffuse(난반사) + Specular(정반사) 합성
*스텐실 : 픽세마다 0 ~ 255 값을 저장하는 마스크 버퍼. 그리기 전후에 비교, 갱신 규칙으로 통과/차단을 제어
*백버퍼 : 현재 프레임을 그리는 오프스크린 컬러 버퍼. 렌더 완료 후 프론트 버퍼와 스왑되어 화면에 표시

유니티 관점에서의 파이프라인
  - 카메라 셋업 : 투영 행렬, 뷰 행렬
  - 섀도우 패스 : 라이트 뷰에서 섀도우 맵 렌더
  - 깊이, 노멀 프리패스 : SSAO*, 스크린 스페이스 섀도우* 등에 활용
  - 불투명 드로우 : ZWrite On, Front-to-Back 정렬로 오버드로우 절감
  - 스카이, 백그라운드 렌더
  - 투명 드로우 : ZWrite Off, Back-to-Front 정렬로 올바른 블렌딩
  - 포스트 프로세싱 : 블룸, 톤매핑 등 후처리
  - UI 합성

*SSAO : 스크린 공간(높이, 노말 버퍼) 에서 접선 부근의 가림(오클루전)을 근사해 음영을 더하는 기법
*스크린 스페이스 섀도우 : 섀도우맵 + 스크린 버퍼(깊이, 노멀, 모션 등)를 이용해 그림자 기여를 화면 공간에서 후처리로 합성하는 기법들의 총칭
*오클루전 : 카메라에서 보이지 않는(가려진) 오브젝트는 아예 그리지 않도록 CPU, GPU 단계에서 제거


## Q : AABB , OBB

AABB :
 - Axis-Aligned Bounding Box의 약자로, 월드 좌표축에 평행한 최소 직육면체를 통해 객체를 감싸는 경계 상자
 - 각 축에 겹침 여부를 통해 충돌 감지를 위해 사용한다.

OBB : 
 - Oriented Bounding Box의 약자로, 축 비정렬 경계 상자를 뜻한다.
 - 세 축이 월드 축과 평행하지 않아도 되며 회전된 오브젝트를 타이트하게 감싸서 AABB보다 정확하지만 연산이 더 많이 필요함


## Q : 종속성 주입

객체가 스스로 의존 대상을 만들지 않고 외부에서 주입해주는 설계방식

  - 장점 :
    - 결합도 감소
    - 테스트 용이성 증가
    - 교체 용이성 증가

유니티에서는 DI 컨테이너(VContainer, Extenject 등)을 이용한 방법이 있음
컨테이너는 등록, 주입, 수명을 관리함


## Q : 인터페이스와 추상클래스의 차이

 - 의도 :
   - 인터페이스 : 행동의 형태
   - 추상클래스 : 이런 방식으로 동작하는 공통 베이스
  
 - 구현 / 상속 :
   - 인터페이스 : 다중 구현 가능
   - 추상클래스 : 단일 상속만 가능
  
 - 접근지정자 :
   - 인터페이스 : public
   - 반드시 public이어야 하는 추상 메서드를 제외한 모든 멤버는 private로 가능


## Q : Async, Await, Task

Async :
  - 비동기 메서드를 선언할 때 사용하는 키워드
  - 키워드가 붙은 메서드는 Task, Task<T> 또는 void를 반환함

Await :
  - 비동기 메서드 내에서 사용되는 키워드
  - Task, Task<T>를 반환하는 메서드나 표현식 앞에 사용 가능
  - 해당 비동기 작업이 완료될 때 까지 현재 메서드의 실행을 중지
  - 작업이 완료되면 메서드의 실행을 재개

Task :
  - Task는 비동기 작업을 나타내는 클래스
  - 메인 스레드를 차단하지 않고 병렬로 실행됨
  - Task<T>는 T 타입의 결과를 반환하는 형태
  - Task는 결과를 반환하지 않는 형태
  - Task의 예외 처리는 직접 처리하지 않으며 Task를 기다리는 코드에서 예외처리를 해야함


## Q : 포톤에서 마스터 클라이언트가 무엇인가?
 
포톤에서 마스터 클라이언트는 일반적으로 우리가 말하는 호스트와 유사한 개념임

마스터 클라이언트 : 
 - 포톤의 방에 참가한 플레이어 중 가장 먼저 입장한 클라이언트

 - 역할
    - 자동 지정 : 방에 처음 들어온 플레이어가 마스터 클라이언트
    - 자동 위임 : 마스터가 나가면 자동으로 다음 플레이어에게 권한 이양
    - 권한 분기 처리 : 게임 로직에서 PhotonNetwork.IsMasterClient로 분기 가능
    - 씬 전환 권한 : PhotonNetwork.LoadLevel() 같은 씬 로딩은 마스터만 실행하도록 하는 경우가 많음
    - 상태 동기화 : 몬스터 AI, 오브젝트 스폰 등 중앙 통제 로직을 마스터에게 위임하는 구조에서 사용됨



## Q : 포톤에서 마스터 서버가 무엇인가?

마스터 서버 :
 - 포톤 클라우드의 중앙 서버 중 하나

 - 역할 : 
    - 클라이언트 접속, 로비 참여, 방 생성/ 입장 요청 등 중계



## Q : 같은 함수지만 상태마다 다르게 구현해야할 필요가 있을 때 어떻게 구현하는지

Ex : 평지를 걷는다, 물에 들어가 수영을 한다, 무중력 상태에서 부양한다 등의 같은 Move 지만 내부 로직이 다름

 - 구현 방법 예시
 1. 공통의 Move 인터페이스를 정의
 2. 인터페이스를 참조한 상태별 클래스를 구현
 3. 플레이어에서 상태를 변경하여 사용



## Q : UI를 오브젝트 안에 넣어서 프리팹으로 관리할 때 장단점

Ex : 1. 몬스터 내부에 UI 포함 (일반 몬스터 위에 따라다니는 체력바, 맞을 때 튀어나오는 데미지 텍스트 등)
 - 장점 :
    - 프리팹 일체화 : 몬스터 프리팹만으로 필요한 요소를 포함하여 관리가 간편
    - 재활용성 : 풀리할 때 별도의 설정 없이 사용 가능
    - 위치 동기화 간편 : UI가 항상 본체의 로컬 위치를 기준으로 움직이므로 위치 처리가 간단함

 - 단점 : 
    - UI 성능 부담 : UI가 3D 오브젝트와 함께 많이 존재하면 캔버스 비용이 증가함
    - UI 제어가 어려움 : 중앙 UI 매니저에서 제어하려면 참조 연결이 번거롭고 분산됨



Ex : 2. UI를 화면(Canvas)에 따로 배치 (보스 몬스터 체력, 타이머 등)
 - 장점 :
    -  일괄 제어 용이 : UIManager에서 하나의 인스턴스만 관리
    - 퍼포먼스 우수 : 화면 UI는 Screen Space - Camera나 Overlay로 최적화 쉬움
    - 직관적 디자인 : 화면 배치가 고정이라 보기 편함

 - 단점 : 
    - 특정 오브젝트 연결 필요 : 화면 UI와 월드 오브젝트 연결은 따로 스크립트가 필요함
    - 여러 보스 지원 어려움 : 보스가 다수라면 UI 동적 인스턴스화 필요



## Q : 이벤트 활용

이벤트는 서로의 존재를 몰라야함 (느슨한 결합) 내가 했다는것만 알리고
구독한 입장에서는 주체자가 알린 정보만으로 주체적으로 해야함



## Q : 플레이어 스테이터스 관리

JSON이나 스크립터블 오브젝트로 초기 데이터 관리

버프 등 후 수정은 스크립트(Modifier)를 통해 조절

발동형 아이템(ex. 공격 시 xx, 피격 시 xx)의 경우 인터페이스 혹은 스크립터블오브젝트를 통해 효과 정의를 하고
이벤트를 통해 호출 (흐름 : 발동 조건 > 호출 > 내부에서 확률 체크 > 실행)



## Q : 대상에 대한 정보 호출

공격 시 RayCast, 물리API(OverlapSphere, SphereCast 등), 콜라이더를 통해 적의 정보를 직접적으로 얻을 수 있지만
이는 강한 결합이므로 인터페이스를 이용해서 공격 대상의 인터페이스의 유무만으로 이벤트를 호출해서 타겟(멀티 시 Photon ID)에게 피격 가능 인터페이스를 탐지해서 피해를 주는 방식이 느슨한 결합을 유지할 수 있어 유지보수에 좋음



## Q : 상태마다 스크립트 바꾸기

상태 패턴을 이용해서 각 상태별 실행할 동작을 미리 구현해두고 상태를 바꿔가면서 변환하면 됨



## Q : 멀티 환경에서 미니게임 플랫폼을 만든다고 했을 때 게임 전환 시 씬 전환을 하는게 나은 방법인지, 하나의 씬에 공간을 분리하고 게임을 모두 만드는게 나은지

씬 전환을 하면 리소스 분리, 독립적인 씬 관리 등의 장점과 로딩 지연, 상태 유지 복잡도 등의 단점이 있고,
단일 씬은 반대로 즉시 전환, 데이터 연속성의 장점이 있지만 메모리 상시 점유 등의 단점이 있다.

그래서 간단한 미니게임의 경우 단일 씬을 유지해도 되지만 리소스와 스크립트가 무겁고 독립적이라면 씬 전환이 유리하다



## Q : 포톤 멀티 환경에서 플레이어가 조작하는 캐릭터를 변경하는 방법

플레이어컨트롤러 끄고 켜기



## Q : 한글 단어를 자음과 모음으로 나누는 법

Unicode 한글 완성형 블록의 구조를 이용해야함

index = code - 0xAC00

초성 인덱스 = index / (21 * 28)

중성 인덱스 = (index % (21 * 28)) / 28

종성 인덱스 = index % 28



## Q : 특정 맵 혹은 특정 바이옴에서 동작이 변경되는 경우

이것도 상태 패턴을 이용해서 처리 가능

그런데 맵별로 동작이 크게 다르다면 전략 패턴으로 분리하는 것도 방법이 될 수 있다.

전략패턴이란 행동을 캡슐화하고 런타임에 그 행동을 바꿔 끼워넣을 수 있도록 해주는 디자인 패턴으로
클래스에 직접 분기문을 넣지 않고, 전략 객체를 주입해서 책임을 위임함으로써 코드 변경 없이 동작 방식을 교체할 수 있음



## Q : 포톤에서 특정 사용자에게 소유권을 할당하는 방법

PhotonView의 소유권을 전환해주면 됨

RequestOwnership() : 로컬 클라이언트에서 이 오브젝트의 소유권을 달라고 요청 > 마스터 클라이언트가 콜백을 통해 처리
TransferOwnership() : 마스터 클라이언트 혹은 현재 Owner가 다른 플레이어에게 직접 소유권을 넘김



## Q : 낙하 위치 계산 방법

포물선 운동 공식활용



## Q : 관전 및 데스캠 구현

관전은 사망 후 컨트롤러 비활성화 및 관전용 카메라를 활성화 시켜 관전할 플레이어의 카메라에 붙이는 식으로 구현

데스캠은 실시간 게임 상태를 버퍼에 저장해 두었다가 사망 후 일정 구간을 꺼내서 재생하는 방식을 사용



## Q : 박싱, 언박싱 활용

박싱 : 값 타입 변수를 object나 인터페이스 타입 변수에 할당할 때 힙에 객체로 복사하는 과정, 새로 할당된 참조 객체가 생성되고 그 내부에 값 타입 데이터가 복사됨

언박싱 : 박싱된 객체를 다시 값 타입으로 복사해 꺼내는 과정



## Q : 스킬을 튕겨내는 구현

스킬 자체가 공격자와 궤적을 가지고 있다면 이 부분만 수정해주면 됨



## Q : 의존성 주입

직접 주입 방식은 의존성이 높지만 명확하고 간단한 방법임

대안으로는 Factory Pattern을 사용할 수 있음

Factory Pattern이란 객체 생성 로직을 별도 클래스로 분리해서 클라이언트가 코드를 구체적인 구현 클래스에 의존하지 않고 무엇을 생성할지만 지정하도록 만드는 생성 디자인 패턴이다.

장점 :
- 생성 코드가 캡슐화되어 클라이언트 코드 경량화
- 클라이언트는 구체적 타입을 몰라도 돼, 확장에 유리하다

단점 : 
 - 클래스와 인터페이스 수가 늘어나 구조 복잡도가 상승
 - 단순한 프로젝트엔 오히려 과잉 설계가 될 수 있다.



## Q : NavMesh 동적처리

런타임 중 NavMeshObstacle 컴포넌트가 부착되고 carving 옵션이 켜져 있으면 오브젝트 생성 시 알아서 그 영역을 NavMesh에서 자동으로 잘라냄
제거 시 carve된 구멍이 사라지고 원래 NavMesh가 복원되어 다시 그 위치를 이동 가능



## Q : 호출 비용

1. 인라인 호출 :

void Update()
{
    // 매 프레임마다 GetComponent<Rigidbody>()를 내부 탐색
    transform.position = GetComponent<Rigidbody>().position + Vector3.up;
}

이런식으로 매 프레임마다 호출하면 호출할 때 마다 비용이 들기 때문에 성능 저하가 될 수 있다.

2. 캐싱 :

private Rigidbody _Rigidbody;

void Awake()
{
    // Awake()에서 한 번만 검색
    _Rigidbody = GetComponent<Rigidbody>();
}

void Update()
{
    // 이후엔 필드를 통해 곧바로 접근 → 탐색 비용 0
    transform.position = _Rigidbody.position + Vector3.up;
}

한 번만 컴포넌트를 찾고, 그 뒤로는 바로 참조하므로 반복 호출 비용이 줄어든다.

그래서 1회성 접근일 경우 인라인 호출을 사용해도 무방하지만 반복 접근이 필요할 경우 캐싱해서 사용하는게 좋다



## Q : Rest API

Rest API는 웹 표준인 HTTP를 기반으로 설계된 아키텍처 스타일로 누가 어떤 자원에 어떤 행위를 요청했는지를 명확히 드러내고
무상태성으로 확장성과 유지보수성을 높이는 데 중점을 두었다는 특징이 있다.



## Q : 충돌 판정

서로 간의 충돌을 감지해야 할 때는 적은 오브젝트 쪽에서 감지를 해야 성능상 이득을 볼 수 있다.
충돌 해제 전 오브젝트가 사라지면 충돌이 해제됐다는 정보를 전해줄 수 없으므로 없어지기 전에 호출해줘서 방지해야 한다.



## Q : 이동하는 발판(플랫폼) 위 같이 이동

1. 플랫폼을 부모로 설정하기
 - 장점 :
    - 플랫폼 움직임을 그대로 상속받는다
    - 구현이 단순하다
      
 - 단점 :
    - 회전, 스케일까지 물려받아 의도치 않은 변형이 발생할 수 있다
    - 네트워크 동기화가 복잡해진다
  
2. 플랫폼 속도를 플레이어 이동에 더하기
 - 장점 :
    -  회전, 스케일 영향 없다
    -  네트워크 동기화에 유리하다
      
 - 단점 :
    - 플랫폼 속도 계산 로직이 필요하다
    - 충돌 해제 시 속도 리셋 로직이 필요하다

3. 물리 조인트 방식
 - 장점 :
    - 물리 엔진이 붙어있는 효과를 자연스럽게 처리된다
    - 마찰, 힘 전달 등 복잡한 순동작까지 물리적으로 구현 가능하다

 - 단점 :
    - Joint 생성/파괴 비용, 파라미터 튜닝 필요하다
    - 캐릭터 컨트롤러와 호환되지 않다

4. 플랫폼 델타 추적 방식
 - 장점 :
    - 부모 자식계층을 변경하지 않으므로 1번에 대한 단점이 없다
    - 캐릭터 컨트롤러, 네브 매쉬 에이전트 등 어디든 적용 가능하다
  
 - 단점 :
    - 플랫폼이 여러 개 겹칠 때 복잡해진다



## Q : 오브젝트 생성 Transform 원리 (로컬 좌표, 월드 좌표)

월드 좌표 : 
 - 유니티 씬 전체의 기준에서 측정한 위치
 - transform.position이 월드 좌표를 나타내고, 씬 내에서 절대적인 위치라고 생각하면 된다.

로컬 좌표 : 
 - 어떤 게임 오브젝트가 다른 오브젝트(부모)의 기준에서 갖는 상대적 위치와 회전
 - transform.localPosition이 로컬 좌표를 나타낸다

Ex. 부모의 오브젝트가 월드 좌표로 (10,0,0)이고 자식의 로컬 좌표가 (1,0,0)이면 자식의 월드 좌표는 (11,0,0)

월드 좌표와 로컬 좌표의 변환을 수식으로 나타낸 것 :
WorldPosition = (LocalPosition * RotationMatrix * ScaleMatrix) + TranslationVector

SetParent의 파라미터 중 worldPositionStays는 부모 변경 시 자식 오브젝트가 보존할 값을 정한다
 - true 라면 부모를 바꿔도 월드 좌표를 유지정



## Q : 시네머신 카메라 경로 설정

Dolly : Chinemachine Spline (경로 오브젝트)와 Cart나 Camera(경로를 따라 움직이는 카메라)를 이용한 방법

사전에 경로를 추가해서 속도나 경로상의 위치를 제어하여 이동



## Q : 이벤트(event) 와 델리게이트(delegate)

이벤트 :
  - 델리게이트를 외부에서 직접 호출하지 못하도록 제한한 멤버
  - 구독 구조를 제공

델리게이트 : 
  - 함수를 참조하는 타입
  - 하나 이상의 메서드를 참조할 수 있는 함수 포인터

이벤트는 델리게이트와 유사한 기능이지만 외부에서는 호출이 불가능하므로 캡슐화를 강제하여 보다 안전한 기능으로 처리할 수 있다



## Q : 포톤에서 특정 플레이어 그룹에게만 RPC나 Instanciate 하는 방법

RPC를 특정 대상에게 보내는 방법
  - 개별 대상으로 보내는 법 :
    - PhotonNetwork.PlayerList 또는 PhotonNetwork.CurrentRoom.Players 등에서 특정 조건으로 필터링
    - RpcTarget은 All, Others, MasterClient 등 사전 정의된 그룹이므로, 사용자 정의 그룹 전송은 불가능하여 여러 명에게 보내려면 수동으로 해야함

Instantiate를 특정 대상에게만 공유하는 방법
  - 따로 제공하는 메소드가 없음 위 방법 처럼 특정 대상에게 RPC로 구현해야 함



## Q : 포톤에서 소유권을 넘기는 방법

생성 시 소유권 지정은 불가능하므로 생성 후 소유권을 마스터나 현재 소유자가 변경해줘야 한다

photonView.TransferOwnership : 마스터나 현재 소유자 만 호출 가능
photonView.RequestOwnership : 현재 소유자가 아닌 사람이 요철할 때 사용(요청 > 승인 구조가 아님, 자동으로 처리됨)



## Q : 연속 공격 등 특정 타이밍에만 입력 받기

bool 로 타이밍 조절

추가 1) 입력이 약간 빠르거나 늦을 경우를 대비해 일정 시간동안 입력 예약을 통해 처리

추가 2) 연속 공격등은 FSM으로 처리
Ex. Attack1 > Attack2 > Attack3 > 종료
이런 구조는 추후 확장이나 수정에 용이함



## Q : A가 B의 상태를 변경해줘야할 때 직접 인터페이스나 이런걸 참조해서 상태를 바꿔주는게 좋은지? 아니면 이벤트를 이용해서 바꾸는게 좋은지?

직접 참조 :
 - 추천 상황 : 강한 결합이 허용되는 경우, A가 B를 명확히 알고 있을 때
 - 장점 : 간단하고 직관적
 - 단점 : B에 대한 의존도가 높아짐

이벤트 : 
 - A와 B가 느슨하게 연결되어야 할 경우
 - 장점 : 느슨한 결함, 재사용 용이
 - 단점 : 흐름 추적이 어려울 수 있음

Ex : A 플레이어가 B 플레이어를 공격을 통해 기절 상태로 만든다
 - 일반적으로 직접 참조 방식을 사용함 (인터페이스 + 직접 호출)
 - 이 경우 이벤트 방식은 비추천 ( A가 B를 알기 때문에 오히려 불명확한 흐름을 만듬)


## Q : 미니맵 구현

방법 1. 라이브 카메라 + RenderTexture, RawImage
 - 월드에 Top-Down 카메라 배치
 - 카메라 출력을 RenderTexture로 받아 UI의 RawImage에 표시

 장점 : 고도 / 지형이 그대로 보이고 제작이 빠름
 단점 : 카메라, RenderTexture 비용

방법 2. URP 카메라 스태킹(Overlay)
 - 메인 카메라, 미니맵 카메라로 한 프레임에 합성
 - Viewport Rect로 화면 일부에 직접 그릴 수도 있고, UI RawImage 없이도 가능

 장점 : RenderTexture 미사용으로 비용 감소, 블러, 마스크 등을 포스트로 섞기 쉬움
 단점 : UI 위에 아이콘을 추가하기 위해 UI와의 정렬 계산이 필요

방법 3. 정적 맵 이미지 + 아이콘
 - 한 장의 맵 이미지를 사용
 - 월드 AABB를 기준으로 좌표 매핑해서 아이콘만 움직임

 장점 : 가벼움
 단점 : 실시간 지형 변화 반영이 어려움












