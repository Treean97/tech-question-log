# Unity-QnA
구현 및 설계에 궁금한 부분 정리 및 기록

##Q : A가 B의 상태를 변경해줘야할 때 직접 인터페이스나 이런걸 참조해서 상태를 바꿔주는게 좋아? 아니면 이벤트를 이용해서 바꾸는게 좋아?##

직접 참조 :
 - 추천 상황 : 강한 결합이 허용되는 경우, A가 B를 명확히 알고 있을 때
 - 장점 : 간단하고 직관적
 - 단점 : B에 대한 의존도가 높아짐

이벤트 : 
 - A와 B가 느슨하게 연결되어야 할 경우
 - 장점 : 느슨한 결함, 재사용 용이
 - 단점 : 흐름 추적이 어려울 수 있음

Ex : A 플레이어가 B 플레이어를 공격을 통해 기절 상태로 만든다
 - 일반적으로 직접 참조 방식을 사용함 (인터페이스 + 직접 호출)
 - 이 경우 이벤트 방식은 비추천 ( A가 B를 알기 때문에 오히려 불명확한 흐름을 만듬)




##Q : 포톤에서 마스터 클라이언트가 무엇인가?
 
포톤에서 마스터 클라이언트는 일반적으로 우리가 말하는 호스트와 유사한 개념임

마스터 클라이언트 : 
 - 포톤의 방에 참가한 플레이어 중 가장 먼저 입장한 클라이언트

 - 역할
    - 자동 지정 : 방에 처음 들어온 플레이어가 마스터 클라이언트
    - 자동 위임 : 마스터가 나가면 자동으로 다음 플레이어에게 권한 이양
    - 권한 분기 처리 : 게임 로직에서 PhotonNetwork.IsMasterClient로 분기 가능
    - 씬 전환 권한 : PhotonNetwork.LoadLevel() 같은 씬 로딩은 마스터만 실행하도록 하는 경우가 많음
    - 상태 동기화 : 몬스터 AI, 오브젝트 스폰 등 중앙 통제 로직을 마스터에게 위임하는 구조에서 사용됨



##Q : 포톤에서 마스터 서버가 무엇인가?##

마스터 서버 :
 - 포톤 클라우드의 중앙 서버 중 하나

 - 역할 : 
    - 클라이언트 접속, 로비 참여, 방 생성/ 입장 요청 등 중계




##Q : 같은 함수지만 상태마다 다르게 구현해야할 필요가 있을 때 어떻게 구현하는지##

Ex : 평지를 걷는다, 물에 들어가 수영을 한다, 무중력 상태에서 부양한다 등의 같은 Move 지만 내부 로직이 다름

 - 구현 방법 예시
 1. 공통의 Move 인터페이스를 정의
 2. 인터페이스를 참조한 상태별 클래스를 구현
 3. 플레이어에서 상태를 변경하여 사용



##Q : UI를 오브젝트 안에 넣어서 프리팹으로 관리할 때 장단점##

Ex : 1. 몬스터 내부에 UI 포함 (일반 몬스터 위에 따라다니는 체력바, 맞을 때 튀어나오는 데미지 텍스트 등)
 - 장점 :
    - 프리팹 일체화 : 몬스터 프리팹만으로 필요한 요소를 포함하여 관리가 간편
    - 재활용성 : 풀리할 때 별도의 설정 없이 사용 가능
    - 위치 동기화 간편 : UI가 항상 본체의 로컬 위치를 기준으로 움직이므로 위치 처리가 간단함

 - 단점 : 
    - UI 성능 부담 : UI가 3D 오브젝트와 함께 많이 존재하면 캔버스 비용이 증가함
    - UI 제어가 어려움 : 중앙 UI 매니저에서 제어하려면 참조 연결이 번거롭고 분산됨


Ex : 2. UI를 화면(Canvas)에 따로 배치 (보스 몬스터 체력, 타이머 등)
 - 장점 :
    -  일괄 제어 용이 : UIManager에서 하나의 인스턴스만 관리
    - 퍼포먼스 우수 : 화면 UI는 Screen Space - Camera나 Overlay로 최적화 쉬움
    - 직관적 디자인 : 화면 배치가 고정이라 보기 편함

 - 단점 : 
    - 특정 오브젝트 연결 필요 : 화면 UI와 월드 오브젝트 연결은 따로 스크립트가 필요함
    - 여러 보스 지원 어려움 : 보스가 다수라면 UI 동적 인스턴스화 필요



##Q : 이벤트 활용##

이벤트는 서로의 존재를 몰라야함 (느슨한 결합) 내가 했다는것만 알리고
구독한 입장에서는 주체자가 알린 정보만으로 주체적으로 해야함



##Q : 플레이어 스테이터스 관리##

JSON이나 스크립터블 오브젝트로 초기 데이터 관리

버프 등 후 수정은 스크립트(Modifier)를 통해 조절

발동형 아이템(ex. 공격 시 xx, 피격 시 xx)의 경우 인터페이스 혹은 스크립터블오브젝트를 통해 효과 정의를 하고
이벤트를 통해 호출 (흐름 : 발동 조건 > 호출 > 내부에서 확률 체크 > 실행)



##Q : 대상에 대한 정보 호출##

공격 시 RayCast, 물리API(OverlapSphere, SphereCast 등), 콜라이더를 통해 적의 정보를 직접적으로 얻을 수 있지만
이는 강한 결합이므로 인터페이스를 이용해서 공격 대상의 인터페이스의 유무만으로 이벤트를 호출해서 타겟(멀티 시 Photon ID)에게 피격 가능 인터페이스를 탐지해서 피해를 주는 방식이 느슨한 결합을 유지할 수 있어 유지보수에 좋음


##Q : 상태마다 스크립트 바꾸기##

상태 패턴을 이용해서 각 상태별 실행할 동작을 미리 구현해두고 상태를 바꿔가면서 변환하면 됨



##Q : 멀티 환경에서 미니게임 플랫폼을 만든다고 했을 때 게임 전환 시 씬 전환을 하는게 나은 방법인지, 하나의 씬에 공간을 분리하고 게임을 모두 만드는게 나은지##

씬 전환을 하면 리소스 분리, 독립적인 씬 관리 등의 장점과 로딩 지연, 상태 유지 복잡도 등의 단점이 있고,
단일 씬은 반대로 즉시 전환, 데이터 연속성의 장점이 있지만 메모리 상시 점유 등의 단점이 있다.

그래서 간단한 미니게임의 경우 단일 씬을 유지해도 되지만 리소스와 스크립트가 무겁고 독립적이라면 씬 전환이 유리하다


##Q : 포톤 멀티 환경에서 플레이어가 조작하는 캐릭터를 변경하는 방법##

플레이어컨트롤러 끄고 켜기



##Q : 한글 단어를 자음과 모음으로 나누는 법##

Unicode 한글 완성형 블록의 구조를 이용해야함

index = code - 0xAC00

초성 인덱스 = index / (21 * 28)

중성 인덱스 = (index % (21 * 28)) / 28

종성 인덱스 = index % 28



##Q : 특정 맵 혹은 특정 바이옴에서 동작이 변경되는 경우##

이것도 상태 패턴을 이용해서 처리 가능

그런데 맵별로 동작이 크게 다르다면 전략 패턴으로 분리하는 것도 방법이 될 수 있다.

전략패턴이란 행동을 캡슐화하고 런타임에 그 행동을 바꿔 끼워넣을 수 있도록 해주는 디자인 패턴으로
클래스에 직접 분기문을 넣지 않고, 전략 객체를 주입해서 책임을 위임함으로써 코드 변경 없이 동작 방식을 교체할 수 있음



##Q : 포톤에서 특정 사용자에게 소유권을 할당하는 방법##

PhotonView의 소유권을 전환해주면 됨

RequestOwnership() : 로컬 클라이언트에서 이 오브젝트의 소유권을 달라고 요청 > 마스터 클라이언트가 콜백을 통해 처리
TransferOwnership() : 마스터 클라이언트 혹은 현재 Owner가 다른 플레이어에게 직접 소유권을 넘김



##Q : 낙하 위치 계산 방법##

포물선 운동 공식활용



##Q : 관전 및 데스캠 구현##

관전은 사망 후 컨트롤러 비활성화 및 관전용 카메라를 활성화 시켜 관전할 플레이어의 카메라에 붙이는 식으로 구현

데스캠은 실시간 게임 상태를 버퍼에 저장해 두었다가 사망 후 일정 구간을 꺼내서 재생하는 방식을 사용



##Q : 박싱, 언박싱 활용##

박싱 : 값 타입 변수를 object나 인터페이스 타입 변수에 할당할 때 힙에 객체로 복사하는 과정, 새로 할당된 참조 객체가 생성되고 그 내부에 값 타입 데이터가 복사됨

언박싱 : 박싱된 객체를 다시 값 타입으로 복사해 꺼내는 과정



##Q : 스킬을 튕겨내는 구현##

스킬 자체가 공격자와 궤적을 가지고 있다면 이 부분만 수정해주면 됨



##Q : 의존성 직접 주입##

직접 주입 방식은 의존성이 높지만 명확하고 간단한 방법임

대안으로는 Factory Pattern을 사용할 수 있음

Factory Pattern이란 객체 생성 로직을 별도 클래스로 분리해서 클라이언트가 코드를 구체적인 구현 클래스에 의존하지 않고 무엇을 생성할지만 지정하도록 만드는 생성 디자인 패턴이다.

장점 :
- 생성 코드가 캡슐화되어 클라이언트 코드 경량화
- 클라이언트는 구체적 타입을 몰라도 돼, 확장에 유리하다

단점 : 
 - 클래스와 인터페이스 수가 늘어나 구조 복잡도가 상승
 - 단순한 프로젝트엔 오히려 과잉 설계가 될 수 있다.

















